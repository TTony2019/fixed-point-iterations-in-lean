import FormalizationFixpointIterations.Nonexpansive.Definitions
import FormalizationFixpointIterations.Theory.WeakSpace
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import FormalizationFixpointIterations.Nonexpansive.Properties

open Nonexpansive_operator Filter Topology TopologicalSpace

local notation "âŸª" aâ‚ ", " aâ‚‚ "âŸ«" => @inner â„ _ _ aâ‚ aâ‚‚

variable {H : Type*} [NormedAddCommGroup H] [InnerProductSpace â„ H]

structure Halpern (T : H â†’ H) where
  x0 : H
  u : H  -- x in 30.1
  x : â„• â†’ H
  Î± : â„• â†’ â„
  update : âˆ€ k : â„•, x (k + 1) = (Î± k) â€¢ u + (1 - Î± k) â€¢ (T (x k))
  initial_value : x 0 = x0

/--
Lemma 30.2: `âˆ€ Î¾ âˆˆ (0,1)`, `ln (1 - Î¾) â‰¤ -Î¾`
-/
lemma log_ineq
  (Î¾ : â„) (hÎ¾ : Î¾ âˆˆ Set.Ioo 0 1) :
  Real.log (1 - Î¾) â‰¤ -Î¾ := by
  have h1 : 1 - Î¾ > 0 := by simp [Set.mem_Ioo] at hÎ¾; linarith
  have h2 : 1 - Î¾ < 1 := by simp [Set.mem_Ioo] at hÎ¾; linarith
  have key := Real.log_le_sub_one_of_pos h1
  linarith

/--
Lemma : `âˆ€ Î± âˆˆ (0,1), 1 - Î± > 0`
-/
lemma one_sub_pos_of_mem_Ioo
  {a : â„} (ha : a âˆˆ Set.Ioo 0 1) : 0 < 1 - a := sub_pos.mpr ha.2

/--
Lemma : `âˆ€ Î± âˆˆ (0,1), 1 - Î± < 1`
-/
lemma one_sub_lt_one_of_mem_Ioo
  {a : â„} (ha : a âˆˆ Set.Ioo 0 1) : 1 - a < 1 := by simp [Set.mem_Ioo] at ha; linarith

/--
Lemma 30.3: `âˆ€ n, Î± n âˆˆ (0,1) â†’ âˆ (1 - Î± n) = exp Î£ log(1 - Î± n)) â‰¤ exp (Î£ -Î± n)`
-/
lemma prod_exp_sum
  {T : H â†’ H} (alg : Halpern T)
  (h_Î±_range : âˆ€ n, alg.Î± n âˆˆ Set.Ioo 0 1) (m n : â„•) :
  âˆ x âˆˆ Finset.Icc m n, (1 - alg.Î± x) = Real.exp (âˆ‘ x âˆˆ Finset.Icc m n, Real.log (1 - alg.Î± x)) âˆ§
    Real.exp (âˆ‘ x âˆˆ Finset.Icc m n, Real.log (1 - alg.Î± x)) â‰¤
      Real.exp (âˆ‘ x âˆˆ Finset.Icc m n, -alg.Î± x) := by
  constructor
  Â· symm; rw [Real.exp_sum]; apply Finset.prod_congr
    Â· ext x; simp
    Â· intro x
      have hk : x âˆˆ Finset.Icc m n â†’ 1 - alg.Î± x > 0 := by
        intro hk_mem
        have := h_Î±_range x
        simp [Set.mem_Ioo] at this; linarith
      intro hx; rw [Real.exp_log]; exact hk hx
  apply Real.exp_le_exp.mpr; apply Finset.sum_le_sum; intro x hx
  exact log_ineq (alg.Î± x) (h_Î±_range x)

/--
Lemma 30.4 : if `lim nâ†’âˆ, Î£ Î± n = âˆ`, `lim nâ†’âˆ âˆ_{k=m}^n (1 - Î± k) = 0`
-/
lemma infinite_prod_zero
  {T : H â†’ H} (alg : Halpern T) (h_Î±_range : âˆ€ n, alg.Î± n âˆˆ Set.Ioo 0 1)
  (h_Î±_sum_inf : Tendsto (fun N => âˆ‘ n âˆˆ Finset.range N, alg.Î± n) atTop atTop) (m : â„•) :
  Tendsto (fun n => âˆ k âˆˆ Finset.Icc m n, (1 - alg.Î± k)) atTop (ğ“ 0) := by
  have h_prod_eq : âˆ€ n â‰¥ m, âˆ k âˆˆ Finset.Icc m n, (1 - alg.Î± k) =
      Real.exp (âˆ‘ k âˆˆ Finset.Icc m n, Real.log (1 - alg.Î± k)) := by
    intro n hn; exact (prod_exp_sum alg h_Î±_range m n).1
  have h_exp_le : âˆ€ n â‰¥ m, Real.exp (âˆ‘ k âˆˆ Finset.Icc m n, Real.log (1 - alg.Î± k)) â‰¤
      Real.exp (âˆ‘ k âˆˆ Finset.Icc m n, -alg.Î± k) := by
    intro n hn; exact (prod_exp_sum alg h_Î±_range m n).2
  have h_prod_le : âˆ€ n â‰¥ m, âˆ k âˆˆ Finset.Icc m n, (1 - alg.Î± k) â‰¤
      Real.exp (- âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k) := by
    intro n hn; rw [h_prod_eq n hn]; convert h_exp_le n hn using 2; simp [Finset.sum_neg_distrib]
  have h_sum_icc_inf : Tendsto (fun n => âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k) atTop atTop := by
    have h_decomp : âˆ€ n â‰¥ m, âˆ‘ k âˆˆ Finset.range (n + 1), alg.Î± k =
        (âˆ‘ k âˆˆ Finset.range m, alg.Î± k) + (âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k) := by
      intro n hn; rw [â† Finset.sum_range_add_sum_Ico _ (Nat.le_succ_of_le hn)]; congr 1
    let C := âˆ‘ k âˆˆ Finset.range m, alg.Î± k
    have h_eq : âˆ€ n â‰¥ m, âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k =
        (âˆ‘ k âˆˆ Finset.range (n + 1), alg.Î± k) - C := by
      intro n hn; have := h_decomp n hn; linarith
    rw [tendsto_atTop_atTop]; intro b
    obtain âŸ¨N, hNâŸ© := (tendsto_atTop_atTop.mp h_Î±_sum_inf) (b + C)
    use max m N; intro n hn
    have hn_m : n â‰¥ m := le_of_max_le_left hn; have hn_N : n â‰¥ N := le_of_max_le_right hn
    rw [h_eq n hn_m]
    have : âˆ‘ k âˆˆ Finset.range (n + 1), alg.Î± k â‰¥ b + C := by apply hN; omega
    linarith
  have h_neg_sum : Tendsto (fun n => -âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k) atTop atBot := by simpa
  have h_exp_to_zero : Tendsto (fun n => Real.exp
    (- âˆ‘ k âˆˆ Finset.Icc m n, alg.Î± k)) atTop (ğ“ 0) := Real.tendsto_exp_atBot.comp h_neg_sum
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds h_exp_to_zero ?_ ?_
  Â· intro n; apply Finset.prod_nonneg; intro k _
    have := h_Î±_range k
    simp [Set.mem_Ioo] at this; linarith
  Â· intro n
    by_cases hn : n â‰¥ m
    Â· exact h_prod_le n hn
    Â· simp [Finset.Icc_eq_empty_of_lt (Nat.not_le.mp hn)]

/--
Lemma : `âˆ€ z âˆˆ C`, `â€–T(x n) - zâ€– â‰¤ â€–x n - zâ€– âˆ§ â€–x n - zâ€– â‰¤ â€–x0 - zâ€–`
-/
lemma halpern_distance_monotone
  {D : Set H} {T : H â†’ H} (hT_nonexp : NonexpansiveOn T D) {C : Set H} (hC : C = Fix T âˆ© D)
  (alg : Halpern T) (halg_x0 : alg.x0 âˆˆ D) (halg_x_in_D : âˆ€ n, alg.x n âˆˆ D)
  (h_Î±_range : âˆ€ n, alg.Î± n âˆˆ Set.Ioo 0 1) (coincidence : alg.u = alg.x0) :
  âˆ€ z âˆˆ C, âˆ€ n, â€–T (alg.x n) - zâ€– â‰¤ â€–alg.x n - zâ€– âˆ§ â€–alg.x n - zâ€– â‰¤ â€–alg.x0 - zâ€– := by
  have hT_quasinonexp := nonexpansive_leadsto_quasinonexpansive hT_nonexp
  intro z hzC n
  induction n with
  | zero =>
    constructor
    Â· have âŸ¨hz_fix, hz_DâŸ© : z âˆˆ Fix T âˆ© D := by convert hzC; exact hC.symm
      have hz_in_fix' : z âˆˆ Fix' T D := âŸ¨hz_D, hz_fixâŸ©
      rw [alg.initial_value]
      exact hT_quasinonexp halg_x0 hz_in_fix'
    Â· rw [alg.initial_value]
  | succ k ih =>
    constructor
    Â· have âŸ¨hz_fix, hz_DâŸ© :z âˆˆ Fix T âˆ© D := by convert hzC; exact hC.symm
      have hz_in_fix' : z âˆˆ Fix' T D := âŸ¨hz_D, hz_fixâŸ©
      exact hT_quasinonexp (halg_x_in_D (k+1)) hz_in_fix'
    Â· rw [alg.update]; calc
        _ = â€–alg.Î± k â€¢ (alg.u - z) + (1 - alg.Î± k) â€¢ (T (alg.x k) - z)â€– := by
              congr 1; simp [smul_sub, sub_smul, add_sub, add_comm]
        _ â‰¤ alg.Î± k * â€–alg.u - zâ€– + (1 - alg.Î± k) * â€–T (alg.x k) - zâ€– := by
              apply norm_add_le_of_le
              Â· simp [norm_smul]; gcongr; rw [abs_of_pos (h_Î±_range k).1]
              Â· simp [norm_smul]; gcongr; rw [abs_of_pos (one_sub_pos_of_mem_Ioo (h_Î±_range k))]
        _ â‰¤ alg.Î± k * â€–alg.x0 - zâ€– + (1 - alg.Î± k) * â€–alg.x k - zâ€– := by
              rw [â† coincidence]; gcongr
              Â· linarith [one_sub_pos_of_mem_Ioo (h_Î±_range k)]
              Â· exact ih.1
        _ â‰¤ alg.Î± k * â€–alg.x0 - zâ€– + (1 - alg.Î± k) * â€–alg.x0 - zâ€– := by
              gcongr
              Â· linarith [one_sub_pos_of_mem_Ioo (h_Î±_range k)]
              Â· exact ih.2
        _ = â€–alg.x0 - zâ€– := by ring

/--
Lemma : `âˆ‘_m^n f k + âˆ‘_(n + 1)^âˆ f k = âˆ‘_m^âˆ f k`
-/
lemma sum_icc_add_tsum_eq_tsum_add
  {f : â„• â†’ â„} (hf : Summable f) (m n : â„•) (hmn : m â‰¤ n) :
  âˆ‘ k âˆˆ Finset.Icc m n, f k + âˆ‘' k, f (k + n + 1) = âˆ‘' k, f (k + m) := by
  -- é¦–å…ˆï¼Œåˆ†è§£ âˆ‘' k, f (k + m) ä¸ºä¸‰éƒ¨åˆ†
  have h_decomp : âˆ‘' k, f (k + m) = âˆ‘ k âˆˆ Finset.Icc m n, f k + âˆ‘' k, f (k + n + 1) := by
    have h_split : âˆ‘' k : â„•, f (k + m) =
        âˆ‘ k âˆˆ Finset.range (n - m + 1), f (k + m) + âˆ‘' k : â„•, f (k + n + 1) := by
      have hf_shift : Summable (fun k => f (k + m)) := by
        apply hf.comp_injective; intro a b hab; linarith
      rw [â† Summable.sum_add_tsum_nat_add]
      Â· congr; ext k; ring_nf; congr 1; rw [Nat.Simproc.add_eq_add_le (1 + k + (n - m)) (1 + k) hmn]
      Â· assumption
    have h_finset_eq : âˆ‘ k âˆˆ Finset.range (n - m + 1), f (k + m) = âˆ‘ k âˆˆ Finset.Icc m n, f k := by
      trans âˆ‘ i âˆˆ Finset.Icc m n, f i
      Â· rw [Finset.sum_bij (fun k _ => k + m)]
        Â· intro k hk; simp only [Finset.mem_range, Finset.mem_Icc] at hk âŠ¢; omega
        Â· intro kâ‚ kâ‚‚ _ _ heq; omega
        Â· intro k hk; use k - m; simp; constructor; repeat simp at hk; omega
        Â· simp
      Â· simp
    rw [h_split, h_finset_eq]
  rw [h_decomp]

/--
Lemma : `lim m n â†’ âˆ`, `Î¼ * Î£_m^n |Î» (k + 1) - Î» k| = 0`
-/
lemma halpern_sum_tail_tendsto_zero
  {T : H â†’ H} (alg : Halpern T) (Î¼ : â„) (hÎ¼_pos : Î¼ > 0)
  (h_Î±_diff_finite : Summable (fun n => |alg.Î± (n + 1) - alg.Î± n|))
  : âˆ€ Îµ > 0, âˆ€á¶  m in atTop, âˆ€á¶  n in atTop, m â‰¤ n â†’ Î¼ * (âˆ‘ k âˆˆ Finset.Icc m n,
    |alg.Î± (k + 1) - alg.Î± k|) < Îµ := by
  intros Îµ Îµ_pos; let f := fun n => |alg.Î± (n + 1) - alg.Î± n|
  have hf := h_Î±_diff_finite
  have h_sum_tail : Tendsto (fun m => âˆ‘' k : â„•, f (k + m)) atTop (ğ“ 0) := by
    exact tendsto_sum_nat_add f
  have h_eventually_tail : âˆ€á¶  m in atTop, âˆ‘' k : â„•, f (k + m) < Îµ / Î¼ := by
    apply (tendsto_order.1 h_sum_tail).2 (Îµ / Î¼) (by positivity)
  have : âˆ€á¶  m in atTop, âˆ€á¶  n in atTop, m â‰¤ n â†’ Î¼ * âˆ‘ k âˆˆ Finset.Icc m n, f k < Îµ := by
    filter_upwards [h_eventually_tail] with m hm; apply eventually_atTop.2; use m
    intro n hmn hmn'
    have h_le : âˆ‘ k âˆˆ Finset.Icc m n, f k â‰¤ âˆ‘' k : â„•, f (k + m) := by calc
        _ â‰¤ âˆ‘ k âˆˆ Finset.Icc m n, f k + âˆ‘' (k : â„•), f (k + n + 1) := by
          simp [f]; apply tsum_nonneg; intro k; exact abs_nonneg _
        _ = âˆ‘' (k : â„•), f (k + m) := sum_icc_add_tsum_eq_tsum_add h_Î±_diff_finite m n hmn
    calc
      _ â‰¤ Î¼ * âˆ‘' k : â„•, f (k + m) := by apply mul_le_mul_of_nonneg_left h_le (le_of_lt hÎ¼_pos)
      _ < Î¼ * (Îµ / Î¼) := mul_lt_mul_of_pos_left hm hÎ¼_pos
      _ = Îµ := by field_simp [ne_of_gt hÎ¼_pos]
  exact this

/--
Lemma : `âˆ_m^n (1 - Î± (k + 1)) = âˆ_(m + 1)^(n + 1) (1 - Î± k)`
-/
lemma h_reindex
  {T : H â†’ H} (alg : Halpern T) :âˆ€ m : â„•, (fun n â†¦ âˆ k âˆˆ Finset.Icc m n, (1 - alg.Î± (k + 1)))
      = (fun n â†¦ âˆ k âˆˆ Finset.Icc (m + 1) (n + 1), (1 - alg.Î± k)) := by
    intro m; ext n; by_cases hn : n â‰¥ m
    Â· let g := fun k => k + 1; let s := Finset.Icc m n; let f := fun k => 1 - alg.Î± k
      have hf : Set.InjOn g â†‘s := by
        intros x hx y hy hxy; exact Nat.succ_inj.mp hxy
      rw [â† Finset.prod_image (s := s) (f := f) (g := g) hf]; congr 1; ext k
      simp only [Finset.mem_image, Finset.mem_Icc]
      constructor
      Â· rintro âŸ¨x, hx, rflâŸ©; constructor
        repeat simp [g, s] at *; rcases hx with âŸ¨hxm, hxnâŸ©; linarith
      Â· intro hk; use k - 1; constructor
        Â· rcases hk with âŸ¨hk1, hk2âŸ©; simp [s, g] at *
          constructor
          Â· exact Nat.le_sub_one_of_lt hk1
          Â· linarith
        rcases hk with âŸ¨hk1, hk2âŸ©; simp [s, g] at *; refine Nat.sub_add_cancel ?_; linarith
    Â· have h_empty1 : Finset.Icc m n = âˆ… := by
        ext x; simp [Finset.mem_Icc]; simp at *; intro hx; linarith
      have h_empty2 : Finset.Icc (m + 1) (n + 1) = âˆ… := by
        ext x; simp [Finset.mem_Icc]; simp at *; intro hx; linarith
      simp [h_empty1, h_empty2, Finset.prod_empty]



/--
Lemma : `lim n â†’ âˆ, Î¼ * âˆ_m^n (1 - Î» (k + 1)) = 0`
-/
lemma halpern_prod_tail_tendsto_zero
  {T : H â†’ H} (alg : Halpern T) (Î¼ : â„) (hÎ¼_pos : Î¼ > 0) (h_Î±_range : âˆ€ n, alg.Î± n âˆˆ Set.Ioo 0 1)
  (h_Î±_sum_inf : Tendsto (fun N => âˆ‘ n âˆˆ Finset.range N, alg.Î± n) atTop atTop) : âˆ€ Îµ > 0, âˆ€ m : â„•,
    âˆ€á¶  n in atTop, m â‰¤ n â†’ Î¼ * âˆ k âˆˆ Finset.Icc m n, (1 - alg.Î± (k + 1)) < Îµ := by
  intros Îµ hÎµ m
  have h_prod_tendsto : Tendsto (fun n => âˆ k âˆˆ Finset.Icc
    (m + 1) (n + 1), (1 - alg.Î± k)) atTop (ğ“ 0) := by
    let f : â„• â†’ â„ := fun n => âˆ k âˆˆ Finset.Icc (m + 1) n, (1 - alg.Î± k)
    have h_f_tendsto : Tendsto f atTop (ğ“ 0) := infinite_prod_zero alg h_Î±_range h_Î±_sum_inf (m + 1)
    apply h_f_tendsto.comp; exact tendsto_add_atTop_nat 1

  have h_eventually : âˆ€á¶  n in atTop, âˆ k âˆˆ Finset.Icc (m + 1) (n + 1), (1 - alg.Î± k) < Îµ / Î¼ := by
    rw [Metric.tendsto_atTop] at h_prod_tendsto
    obtain âŸ¨N, hNâŸ© := h_prod_tendsto (Îµ / Î¼) (by positivity)
    rw [eventually_atTop]; use N; intro n hn
    have := hN n hn; rw [Real.dist_eq] at this; simp at this; exact lt_of_abs_lt this

  rw [eventually_atTop]; obtain âŸ¨N, hNâŸ© := (eventually_atTop).mp h_eventually
  use max m N; intro n hn hmn; have hn_N : n â‰¥ N := le_of_max_le_right hn; calc
    _ = Î¼ * âˆ k âˆˆ Finset.Icc (m + 1) (n + 1), (1 - alg.Î± k) := by
      congr 1; exact congrFun (h_reindex alg m) n
    _ < Î¼ * (Îµ / Î¼) := mul_lt_mul_of_pos_left (hN n hn_N) hÎ¼_pos
    _ = Îµ := by field_simp [ne_of_gt hÎ¼_pos]


/--
Lemma : `lim n â†’ âˆ`, `x (n k) - T (x (n k)) = 0`
-/
lemma halpern_subseq_x_sub_Tx_tendsto_zero
  {T : H â†’ H} (alg : Halpern T) (n : â„• â†’ â„•) (h_n_strict_mono : âˆ€ i j, i < j â†’ n i < n j)
  (h_x_Tx_limit : Tendsto (fun n â†¦ alg.x n - T (alg.x n)) atTop (ğ“ 0))
  : Tendsto (fun k => alg.x (n k) - T (alg.x (n k))) atTop (ğ“ 0) := by
  have h_n_k_ge_k : âˆ€ k, n k â‰¥ k := by apply StrictMono.nat_id_le h_n_strict_mono
  rw [Metric.tendsto_atTop] at h_x_Tx_limit âŠ¢; intro Îµ Îµ_pos; obtain âŸ¨N, hNâŸ© := h_x_Tx_limit Îµ Îµ_pos
  use N; intro k hk; specialize hN (n k) (Nat.le_trans hk (h_n_k_ge_k k))
  rw [dist_eq_norm] at hN âŠ¢; exact hN

/--
Lemma : `x n k â‡€ z` âˆ§ `lim n â†’ âˆ, x (n k) - T (x (n k)) = 0` â†’ `z âˆˆ Fix T`
-/
lemma halpern_subseq_fixed_point [CompleteSpace H]
  {D : Set H} (hD_closed : IsClosed D) (hD_convex : Convex â„ D) (hD_nonempty : D.Nonempty)
  {T : H â†’ H} (hT_nonexp : NonexpansiveOn T D) (alg : Halpern T) (n : â„• â†’ â„•) (z : H)
  (h_z_in_D : z âˆˆ D) (h_z_weak_limit : WeakConverge (alg.x âˆ˜ n) z) (halg_x_in_D : âˆ€ n, alg.x n âˆˆ D)
  (h_subseq_x_Tx_limit : Tendsto (fun k => alg.x (n k) - T (alg.x (n k))) atTop (ğ“ 0))
  : z âˆˆ Fix T := corollary_4_28 hD_closed hD_convex hD_nonempty hT_nonexp (alg.x âˆ˜ n)
    (fun k => halg_x_in_D (n k)) z h_z_in_D h_z_weak_limit h_subseq_x_Tx_limit



/--
Lemma 2.45 : `âˆ€ n, â€–x nâ€– â‰¤ M` â†’ `âˆƒ (Ï† : â„• â†’ â„•) (p : H),
  (âˆ€ m n, m < n â†’ Ï† m < Ï† n) âˆ§ WeakConverge (x âˆ˜ Ï†) p`
-/
lemma bounded_seq_weakly_convergent_subsequence [SeparableSpace H] [CompleteSpace H]
  (x : â„• â†’ H) (h_bounded : âˆƒ M, âˆ€ n, â€–x nâ€– â‰¤ M) :
  âˆƒ (Ï† : â„• â†’ â„•) (p : H), (âˆ€ m n, m < n â†’ Ï† m < Ï† n) âˆ§ WeakConverge (x âˆ˜ Ï†) p := by
  obtain âŸ¨M, hMâŸ© := h_bounded
  have h_is_bounded : Bornology.IsBounded (Set.range fun n => â€–x nâ€–) := by
    rw [Bornology.IsBounded]; use 2 * M; intro m hm n hn; simp at *
    rcases hm with âŸ¨k, rflâŸ©; rcases hn with âŸ¨l, rflâŸ©
    calc
      _ â‰¤ â€–x kâ€– + â€–x lâ€– :=
        abs_sub_le_of_nonneg_of_le (norm_nonneg _) (by simp) (norm_nonneg _) (by simp)
      _ â‰¤ M + M := add_le_add (hM k) (hM l)
      _ = 2 * M := by ring
  obtain âŸ¨a, Ï†, h_strict_mono, h_weak_convâŸ© :=
    bounded_seq_has_weakly_converge_subseq_separable x h_is_bounded
  have h_phi_explicit : âˆ€ m n, m < n â†’ Ï† m < Ï† n := fun m n a â†¦ h_strict_mono a
  exact âŸ¨Ï†, a, h_phi_explicit, h_weak_convâŸ©

/--
Definition : `âˆƒ u âˆˆ C, â€–x - uâ€– = inf_{w âˆˆ C} â€–x - wâ€–`
-/
theorem existence_of_projection_point [CompleteSpace H]
  (C : Set H) (hC1 : C.Nonempty) (hC2 : Convex â„ C) (hC3 : IsClosed C) (x : H) :
  âˆƒ u âˆˆ C, â€–x - uâ€– = â¨… w : C, â€–x - wâ€– :=
  exists_norm_eq_iInf_of_complete_convex hC1 (IsClosed.isComplete hC3) hC2 x

/--
Proposition : `â€–x - PCxâ€– = inf_{w âˆˆ C} â€–x - wâ€–` â†’ `âˆ€ w âˆˆ C, âŸªx - PCx, w - PCxâŸ« â‰¤ 0`
-/
theorem proj_pt_inner_le_zero
  (x PCx : H) (C : Set H) (hC2 : Convex â„ C) (hPCx : PCx âˆˆ C) (hP : â€–x - PCxâ€– = â¨… w : C, â€–x - wâ€–) :
  âˆ€ w âˆˆ C, inner â„ (x - PCx) (w - PCx) â‰¤ 0 := (norm_eq_iInf_iff_real_inner_le_zero hC2 hPCx).1 hP

/--
Lemma : `âˆƒ M > 0, lim n â†’ âˆ, âŸªT (x n) - PCx, x - PCxâŸ« â‰¤ M`
-/
lemma halpern_inner_bounded_of_limsup
  {T : H â†’ H} (alg : Halpern T) (m : H) (Î¼ : â„) (hÎ¼_Tx_bound : âˆ€ n, â€–alg.u - T (alg.x n)â€– â‰¤ Î¼)
  (h_limsup_neg : limsup (fun k â†¦ inner â„ (T (alg.x k) - m) (alg.u - m)) atTop â‰¤ 0)
  : âˆƒ M, âˆ€á¶  n in atTop, âŸªT (alg.x n) - m, alg.u - mâŸ« â‰¤ M := by
  have : âˆƒ N, âˆ€á¶  n in atTop, âŸªT (alg.x n) - m, alg.u - mâŸ« < N := by
    have h_limsup_neg' : limsup (fun k â†¦ inner â„ (T (alg.x k) - m) (alg.u - m)) atTop < 1 := by
      linarith
    use 1; apply Filter.eventually_lt_of_limsup_lt h_limsup_neg' ?_
    simp [IsBoundedUnder, IsBounded]; use (Î¼ + â€–alg.u - mâ€–) * â€–alg.u - mâ€–; use 0; intro b hb; calc
      _ â‰¤ â€–T (alg.x b) - mâ€– * â€–alg.u - mâ€– := real_inner_le_norm (T (alg.x b) - m) (alg.u - m)
      _ = â€–(T (alg.x b) - alg.u) + (alg.u - m)â€– * â€–alg.u - mâ€– := by simp
      _ â‰¤ (â€–T (alg.x b) - alg.uâ€– + â€–alg.u - mâ€–) * â€–alg.u - mâ€– := by
        apply mul_le_mul (norm_add_le (T (alg.x b) - alg.u) (alg.u - m)) (by simp)
          (norm_nonneg (alg.u - m)); rw [â† zero_add 0]
        apply add_le_add (norm_nonneg (T (alg.x b) - alg.u)) (norm_nonneg (alg.u - m))
      _ â‰¤ (Î¼ + â€–alg.u - mâ€–) * â€–alg.u - mâ€– := by
        apply mul_le_mul ?_ (by simp) (by simp) ?_
        Â· simp; specialize hÎ¼_Tx_bound b; calc
            _ = â€–alg.u - T (alg.x b)â€– := by rw [norm_sub_rev]
            _ â‰¤ Î¼ := hÎ¼_Tx_bound
        Â· have : Î¼ â‰¥ 0 := by specialize hÎ¼_Tx_bound b; linarith [norm_nonneg (alg.u - T (alg.x b))]
          rw [â† zero_add 0]; apply add_le_add this (norm_nonneg (alg.u - m))
  rcases this with âŸ¨N, hNâŸ©; use N; filter_upwards [hN] with n hn; linarith

/--
Lemma : `â€–x n - zâ€– â‰¤ M1` â†’ `â€–x (n + 1) - PCxâ€– ^ 2 â‰¤ M2`
-/
lemma halpern_norm_sq_bounded
  {T : H â†’ H} (alg : Halpern T) (z m : H) (h_seq_bounded : âˆƒ M, âˆ€ n, â€–alg.x n - zâ€– â‰¤ M)
  : âˆƒ M : â„, âˆ€ n : â„•, â€–alg.x (n + 1) - mâ€– ^ 2 â‰¤ M := by
  obtain âŸ¨M, hMâŸ© : âˆƒ M, âˆ€ (n : â„•), â€–alg.x (n + 1) - zâ€– â‰¤ M := by
    rcases h_seq_bounded with âŸ¨M,hMâŸ©; use M; intro n; exact hM (n + 1)
  use (M + â€–z - mâ€–) ^ 2; intro n; calc
    _ = â€–alg.x (n + 1) - z + z - mâ€– ^ 2 := by simp
    _ â‰¤ (â€–alg.x (n + 1) - zâ€– + â€–z - mâ€–) ^ 2 := by
      apply sq_le_sq.mpr; simp
      have : â€–alg.x (n + 1) - zâ€– + â€–z - mâ€– â‰¥ 0 := add_nonneg (norm_nonneg _) (norm_nonneg _)
      rw [abs_of_nonneg this]; exact norm_sub_le_norm_sub_add_norm_sub (alg.x (n + 1)) z m
    _ â‰¤ (M + â€–z - mâ€–) ^ 2 := by
      apply sq_le_sq.mpr; simp [abs_of_nonneg (add_nonneg (norm_nonneg _) (norm_nonneg _))]
      rw [abs_of_nonneg]
      Â· exact add_le_add_right (hM n) â€–z - mâ€–
      Â· apply add_nonneg ?_ (norm_nonneg _); specialize hM 0
        have : â€–alg.x (0 + 1) - zâ€– â‰¥ 0 := norm_nonneg _; linarith

/--
Lemma 30.15 : `âˆƒ (n : â„• â†’ â„•) (z PCx : H) (q : â„• â†’ â„),
  (âˆ€ i j, i < j â†’ n i < n j) âˆ§ (z âˆˆ D âˆ§ WeakConverge (x âˆ˜ n) z) âˆ§
  (PCx âˆˆ C âˆ§ â€–x - PCxâ€– = inf_{w âˆˆ C} â€–x - wâ€–) âˆ§
  (q = fun n => âŸªT (x n) - PCx, x - PCxâŸ«) âˆ§
  (Tendsto (q âˆ˜ n) atTop (ğ“ (limsup q atTop)))`
-/
lemma halpern_subsequence_weak_convergence [CompleteSpace H] [SeparableSpace H]
  {D : Set H} (hD_closed : IsClosed D) (hD_convex : Convex â„ D) {T : H â†’ H} {C : Set H}
  (hT_fixpoint : C.Nonempty) (alg : Halpern T)
  (halg_x_in_D : âˆ€ n, alg.x n âˆˆ D) (h_C_closed_convex : IsClosed C âˆ§ Convex â„ C)
  (h_xn_bounded : âˆƒ M, âˆ€ n, â€–alg.x nâ€– â‰¤ M) (h_Txn_bounded : âˆƒ M, âˆ€ (n : â„•), â€–T (alg.x n)â€– â‰¤ M) :
  âˆƒ (n : â„• â†’ â„•) (z : H) (m : H) (q : â„• â†’ â„), (âˆ€ i j, i < j â†’ n i < n j) âˆ§
    (z âˆˆ D âˆ§ WeakConverge (alg.x âˆ˜ n) z) âˆ§ (m âˆˆ C âˆ§ â€–alg.u - mâ€– = â¨… w : C, â€–alg.u - wâ€–) âˆ§
      (q = fun n => âŸªT (alg.x n) - m, alg.u - mâŸ«) âˆ§
        (Tendsto (q âˆ˜ n) atTop (ğ“ (limsup q atTop))) := by
  have h_C_closed : IsClosed C := h_C_closed_convex.1
  have h_C_convex : Convex â„ C := h_C_closed_convex.2
  obtain âŸ¨m, hm_in_C, hm_projâŸ© :=
    existence_of_projection_point C hT_fixpoint h_C_convex h_C_closed alg.u

  let q : â„• â†’ â„ := fun n => âŸªT (alg.x n) - m, alg.u - mâŸ«; rcases h_Txn_bounded with âŸ¨M_Tx, hM_TxâŸ©
  have hq_bdd : âˆƒ M : â„, âˆ€ k : â„•, |q k| â‰¤ M := by
    use (M_Tx + â€–mâ€–) * â€–alg.u - mâ€–; intro k; calc
      _ = |âŸªT (alg.x k) - m, alg.u - mâŸ«| := rfl
      _ = max (âŸªT (alg.x k) - m, alg.u - mâŸ«) (-âŸªT (alg.x k) - m, alg.u - mâŸ«) := rfl
      _ = max (âŸªT (alg.x k) - m, alg.u - mâŸ«) (âŸª-(T (alg.x k) - m), alg.u - mâŸ«) := by
        congr; exact Eq.symm (inner_neg_left (T (alg.x k) - m) (alg.u - m))
      _ â‰¤ â€–T (alg.x k) - mâ€– * â€–alg.u - mâ€– := by
        apply max_le (real_inner_le_norm (T (alg.x k) - m) (alg.u - m)) ?_
        calc
          _ â‰¤ â€–-(T (alg.x k) - m)â€– * â€–alg.u - mâ€– :=
            real_inner_le_norm (-(T (alg.x k) - m)) (alg.u - m)
          _ = â€–T (alg.x k) - mâ€– * â€–alg.u - mâ€– := by rw [norm_neg]
      _ â‰¤ (â€–T (alg.x k)â€– + â€–mâ€–) * â€–alg.u - mâ€– := mul_le_mul_of_nonneg_right
        (norm_sub_le (T (alg.x k)) m) (norm_nonneg _)
      _ â‰¤ (M_Tx + â€–mâ€–) * â€–alg.u - mâ€– := by
        apply mul_le_mul_of_nonneg_right ?_ (norm_nonneg _); simp; exact hM_Tx k

  have h_subseq_q : âˆƒ (k : â„• â†’ â„•), StrictMono k âˆ§ Tendsto (q âˆ˜ k) atTop (ğ“ (limsup q atTop)) := by
    obtain âŸ¨Ï†, L, h_strict_mono, h_L_eq, h_tendstoâŸ© := lim_subsequence_eq_limsup q hq_bdd
    exact âŸ¨Ï†, h_strict_mono, by rwa [â† h_L_eq]âŸ©
  obtain âŸ¨k, h_k_strict_mono, h_k_tendstoâŸ© := h_subseq_q
  have h_xk_bounded : âˆƒ M, âˆ€ j, â€–alg.x (k j)â€– â‰¤ M := by
    obtain âŸ¨M, hMâŸ© := h_xn_bounded; exact âŸ¨M, fun j => hM (k j)âŸ©
  obtain âŸ¨l, z, h_l_strict_mono, h_weak_xkl_to_zâŸ© :=
    bounded_seq_weakly_convergent_subsequence (alg.x âˆ˜ k) h_xk_bounded

  have h_z_in_D : z âˆˆ D := by
    have h_x_in_D : âˆ€ j, alg.x (k (l j)) âˆˆ D := fun j => halg_x_in_D _
    have h_D_weakly_closed : IsWeaklyClosed D := by
      apply closed_is_weakly_closed
      Â· exact hD_convex
      Â· exact hD_closed
    have h_D_weakly_seq_closed : IsWeaklySeqClosed D := by
      apply weakly_closed_seq_closed; exact h_D_weakly_closed
    simp only [IsWeaklySeqClosed] at h_D_weakly_seq_closed
    apply h_D_weakly_seq_closed h_x_in_D h_weak_xkl_to_z

  let n : â„• â†’ â„• := k âˆ˜ l
  have h_n_strict_mono : âˆ€ i j, i < j â†’ n i < n j := by
    intro i j hij; unfold n; simp only [Function.comp_apply]
    exact h_k_strict_mono (h_l_strict_mono i j hij)

  have h_n_tendsto : Tendsto (q âˆ˜ n) atTop (ğ“ (limsup q atTop)) := by
    have h_comp : (q âˆ˜ n) = (q âˆ˜ k) âˆ˜ l := by funext j; simp only [Function.comp_apply, n]
    rw [h_comp]; apply h_k_tendsto.comp; exact StrictMono.tendsto_atTop h_l_strict_mono
  exact âŸ¨n, z, m, q, h_n_strict_mono, âŸ¨h_z_in_D, h_weak_xkl_to_zâŸ©,
    âŸ¨hm_in_C, hm_projâŸ©, rfl, h_n_tendstoâŸ©

/--
Lemma 30.16 : `limsup n â†’ âˆ, âŸªT (x n) - PCx, x - PCxâŸ« â‰¤ 0`
-/
lemma halpern_limsup_inner_le_zero [CompleteSpace H]
  {D : Set H} {T : H â†’ H} {C : Set H} (hC : C = Fix T âˆ© D)
  (hC_closed_convex : IsClosed C âˆ§ Convex â„ C) (alg : Halpern T) (n : â„• â†’ â„•) (z : H)
  (h_z_in_C : z âˆˆ C) (h_weak_xn_to_z : WeakConverge (alg.x âˆ˜ n) z) (m : H) (hm_in_C : m âˆˆ C)
  (hm_proj : â€–alg.u - mâ€– = â¨… w : C, â€–alg.u - wâ€–)
  (h_subseq_x_Tx_limit : Tendsto (fun k => alg.x (n k) - T (alg.x (n k))) atTop (ğ“ 0))
  (h_n_tendsto : Tendsto (fun k => âŸªT (alg.x (n k)) - m, alg.u - mâŸ«) atTop
  (ğ“ (limsup (fun n => âŸªT (alg.x n) - m, alg.u - mâŸ«) atTop)))
  : limsup (fun k => âŸª(T (alg.x k) - m), (alg.u - m)âŸ«) atTop â‰¤ 0 := by
  have h_subseq_inner_limit1 : Tendsto
    (fun k => âŸªT (alg.x (n k)) - alg.x (n k), alg.u - mâŸ«) atTop (ğ“ 0) := by
      rw [Metric.tendsto_atTop] at h_subseq_x_Tx_limit âŠ¢; intro Îµ Îµ_pos; let R := â€–alg.u - mâ€–
      by_cases hR : R = 0
      Â· use 0; intro k hk; rw [Real.dist_eq]; simp only [sub_zero]
        have h_vec_zero : alg.u - m = 0 := norm_eq_zero.mp hR
        simp [inner_zero_right, h_vec_zero]; linarith
      Â· have hR_pos : 0 < R := by
          simp only [R]
          exact norm_pos_iff.mpr (by
            intro h_eq; have : â€–alg.u - mâ€– = 0 := by simp [h_eq]
            exact hR this)
        obtain âŸ¨N, hNâŸ© := h_subseq_x_Tx_limit (Îµ / R) (by positivity); use N; intro k hk
        specialize hN k hk; simp [dist_eq_norm] at hN; rw [Real.dist_eq]; simp only [sub_zero]; calc
          _ â‰¤ â€–T (alg.x (n k)) - alg.x (n k)â€– * â€–alg.u - mâ€– := by apply abs_real_inner_le_norm
          _ = â€–alg.x (n k) - T (alg.x (n k))â€– * â€–alg.u - mâ€– := by congr 1; rw [norm_sub_rev]
          _ < (Îµ / R) * R := mul_lt_mul_of_pos_right hN hR_pos
          _ = Îµ := by field_simp [ne_of_gt hR_pos]

  have h_subseq_inner_limit2 : Tendsto (fun k => âŸªalg.x (n k), alg.u - mâŸ«) atTop (ğ“ âŸªz , alg.u - mâŸ«)
    := by rw [weakConverge_iff_inner_converge] at h_weak_xn_to_z; apply h_weak_xn_to_z (alg.u - m)

  have h_subseq_inner_limit3 : Tendsto (fun k => âŸªalg.x (n k) - m, alg.u - mâŸ«) atTop
    (ğ“ âŸªz - m, alg.u - mâŸ«) := by
      by_cases h_eq : alg.u = m
      Â· simp [h_eq]
      Â· rw [Metric.tendsto_atTop]at h_subseq_inner_limit2 âŠ¢; intro Îµ Îµ_pos
        obtain âŸ¨N, hNâŸ© := h_subseq_inner_limit2 Îµ (by positivity); use N; intro k hk
        specialize hN k hk; rw [Real.dist_eq] at hN âŠ¢; calc
          _ = |âŸªalg.x (n k), alg.u - mâŸ«- âŸªz, alg.u - mâŸ«| := by
            congr 1; simp [inner_sub_left, inner_sub_left]
          _ < Îµ := hN

  have h_proj_ineq : âŸªalg.u - m, z - mâŸ« â‰¤ 0 := by
    have hm_in_D : m âˆˆ D := by rw [hC] at hm_in_C; exact Set.mem_of_mem_inter_right hm_in_C
    have h_proj_apply : âˆ€ w âˆˆ C, âŸªalg.u - m, w - mâŸ« â‰¤ 0 :=
      proj_pt_inner_le_zero alg.u m C hC_closed_convex.2 hm_in_C hm_proj
    exact h_proj_apply z h_z_in_C

  have h_subseq_inner_limit4 : Tendsto (fun k => âŸª T (alg.x (n k)) - m, alg.u - mâŸ«) atTop
    (ğ“ âŸªz - m, alg.u - mâŸ«) := by
      have h_inner_diff : âˆ€ k, âŸª T (alg.x (n k)) - m, alg.u - mâŸ« = âŸª T (alg.x (n k)) -
        alg.x (n k), alg.u - mâŸ« + âŸª alg.x (n k) - m, alg.u - mâŸ« := by
        intro k; simp [inner_sub_left, inner_sub_left, inner_sub_left]
      convert Tendsto.add h_subseq_inner_limit1 h_subseq_inner_limit3 using 1
      Â· funext k; exact h_inner_diff k
      Â· simp

  have h_limsup_eq : limsup (fun k => âŸª(T (alg.x k) - m), (alg.u - m)âŸ«) atTop
    = âŸªz - m, alg.u - mâŸ« := tendsto_nhds_unique h_n_tendsto h_subseq_inner_limit4
  calc
    _ = âŸªz - m, alg.u - mâŸ« := h_limsup_eq
    _ = âŸªalg.u - m, z - mâŸ« := real_inner_comm (alg.u - m) (z - m)
    _ â‰¤ 0 := h_proj_ineq
